import os
import subprocess
import toml
from omegaconf import DictConfig


def write_tfvars_file(tfvars_file, config: DictConfig) -> None:
    """ Write tfvars file ensuring all output is valid TOML """
    for var in config:
        if type(config[var]) == DictConfig:
            tfvars_file.write(f"\n# {var}\n")
            write_tfvars_file(tfvars_file, config[var])  # Recurse through dictionaries
        else:
            output = {var: config[var]}
            tfvars_file.write(toml.dumps(output))  # Ensure vars files generate valid TOML


def generate_terraform_config(path: str, s3_backend_key: str) -> None:
    """ Create new terraform config files to enable app to apply multiple configs from one terraform module """
    replacements = {'BACKEND_S3_KEY': s3_backend_key}
    with open('../../../terraform/terraform_config.tf') as infile, open(f'{path}/config.tf', 'w') as outfile:
        # Script working dir is the hydra output dir, hence need to navigate up dirs
        for line in infile:
            for src, target in replacements.items():
                line = line.replace(src, target)
            outfile.write(line)


def create_infrastructure(cfg: DictConfig) -> None:
    """ Parses all terraform_config generates tfvars file then calls terraform to generate it """
    for key in cfg:
        if "terraform_config" not in cfg[key]:
            continue  # Skip elements that don't have terraform config in them

        tfvars = cfg[key].terraform_config.tfvars_file
        print(f"Generating tfvars file {tfvars.path}/{tfvars.filename}")
        os.makedirs(tfvars.path, exist_ok=True)
        with open(f"{tfvars.path}/{tfvars.filename}", 'w') as tfvars_file:
            tfvars_file.write("# Config generated by terravarmer\n")
            write_tfvars_file(tfvars_file, cfg[key].tfvars_config)
            generate_terraform_config(tfvars.path, cfg[key].terraform_config.s3_backend_key)

        if cfg.build.run_terraform:
            run_terraform(terraform_mode="apply", infrastructure=key, path=tfvars.path, filename=tfvars.filename)


def destroy_infrastructure(cfg: DictConfig) -> None:
    """ Controls destruction of all infra created """
    if not cfg.build.run_terraform:
        print("Destroy infrastructure - build.run_terraform set to false, exiting")
        return

    # To destroy infra we just have to destroy them in the reverse order than they were created
    for module in reversed(cfg.keys()):
        if "terraform_config" not in cfg[module]:
            continue  # Skip elements that don't have tfvars

        tfvars = cfg[module].terraform_config.tfvars_file
        generate_terraform_config(tfvars.path, cfg[module].terraform_config.s3_backend_key)
        run_terraform(terraform_mode="destroy", infrastructure=module, path=tfvars.path, filename=tfvars.filename)


def run_terraform(terraform_mode: str, infrastructure: str, path: str, filename: str) -> None:
    """ Launch terraform and apply all config files """
    assert terraform_mode in ["apply", "destroy"]
    working_dir = os.getcwd()
    print(f"Terraform {terraform_mode}ing {infrastructure} infrastructure specified in {filename}")
    os.chdir(path)
    # Clean ahead of modifying infra
    clean_cmd = "rm -Rf .terraform && rm .terraform.lock.hcl"
    subprocess.run(clean_cmd.split(" "), check=True)

    # Initialise Terraform
    init_cmd = f"terraform init --backend-config=/tools/terraform/config/backend_prod.config"
    subprocess.run(init_cmd.split(" "), check=True)

    # Modify infrastructure using generated tfvars file
    apply_cmd = f"terraform {terraform_mode} -var-file={filename} -auto-approve"
    subprocess.run(apply_cmd.split(" "), check=True)
    os.chdir(working_dir)  # Revert to original working dir, to ensure script not confused
